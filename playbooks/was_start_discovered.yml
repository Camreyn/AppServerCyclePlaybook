---
# =============================================================================
# was_start_discovered.yml
# Start discovered WAS application servers on limited tier hosts
#
# This playbook:
#   1. Runs pre-flight checks (su-to-wsadmin, script staging)
#   2. Optionally starts DMGR (if was_start_dmgr is true)
#   3. Waits for DMGR SOAP port
#   4. Optionally starts nodeagent on each host (if was_start_nodeagent is true)
#   5. Discovers application servers for nodes in scope
#   6. Starts each discovered application server via wsadmin
#   7. Optionally verifies servers are running
#
# Required variables:
#   - was_dmgr_host: DMGR hostname (delegate target)
#   - was_dmgr_profile: Path to DMGR profile (e.g., /opt/WebSphere/AppServer/profiles/Dmgr01)
#   - was_wsadmin_user: wsadmin SOAP authentication user
#   - was_wsadmin_pass: wsadmin SOAP authentication password
#   - was_node_profile_path: Per-host path to node profile
#   - was_node_name: Per-host WebSphere node name
#   - was_allow_disruptive: Must be true to proceed (safety gate)
#
# Optional variables:
#   - was_run_user: OS user to run wsadmin as (default: wsadmin)
#   - was_dmgr_soap_port: DMGR SOAP port (default: 8879)
#   - was_dmgr_soap_wait_timeout_sec: Timeout waiting for SOAP port (default: 300)
#   - was_poll_timeout_sec: Timeout for server start operation (default: 600)
#   - was_poll_delay_sec: Delay between state checks (default: 5)
#   - was_start_dmgr: Whether to start DMGR first (default: true)
#   - was_start_nodeagent: Whether to start nodeagent before servers (default: true)
#   - was_verify_after_start: Whether to verify servers are running (default: true)
# =============================================================================

- name: Start discovered WAS application servers on limited tier hosts
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  vars:
    # OS user that should run wsadmin.sh
    was_run_user: "wsadmin"
    # Wrapper: run a command as wsadmin via sudo su (no Ansible become required)
    # This matches the command-line pattern: sudo su - wsadmin -c "command"
    was_su_wsadmin_prefix: "sudo su - {{ was_run_user }} -c"

    # Where we stage Jython scripts on the DMGR host (no root required)
    was_wsadmin_stage_dir: "/tmp/was_wsadmin_scripts"

    # DMGR SOAP configuration
    was_dmgr_soap_port: "8879"
    was_dmgr_soap_wait_timeout_sec: "300"

    # Server control timeouts
    was_poll_timeout_sec: "600"
    was_poll_delay_sec: "5"

    # Optional behavior toggles
    was_start_dmgr: "true"
    was_start_nodeagent: "true"
    was_verify_after_start: "true"

  tasks:
    # ==========================================================================
    # Safety check - require explicit approval
    # ==========================================================================
    - name: Safety check - require explicit approval for disruptive actions
      ansible.builtin.assert:
        that:
          - was_allow_disruptive | default(false) | bool
        fail_msg: >
          Disruptive actions are disabled.
          Set was_allow_disruptive=true (survey/extra vars) to proceed.
      run_once: true
      become: false

    # ==========================================================================
    # Validate required variables
    # ==========================================================================
    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_profile_path is defined
          - was_node_profile_path | length > 0
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Ensure DMGR vars (was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass) and per-host node vars (was_node_profile_path,
          was_node_name) are set via inventory or survey.
      become: false

    # ==========================================================================
    # DMGR pre-checks - verify wsadmin.sh exists
    # ==========================================================================
    - name: DMGR precheck - ensure wsadmin.sh exists
      ansible.builtin.stat:
        path: "{{ was_dmgr_profile }}/bin/wsadmin.sh"
      register: dmgr_wsadmin_stat
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Fail if wsadmin.sh missing on DMGR
      ansible.builtin.assert:
        that:
          - dmgr_wsadmin_stat.stat.exists
        fail_msg: "wsadmin.sh not found at {{ was_dmgr_profile }}/bin/wsadmin.sh on DMGR host {{ was_dmgr_host }}"
      run_once: true
      become: false

    # ==========================================================================
    # Stage wsadmin scripts to /tmp (no root required)
    # ==========================================================================
    - name: Ensure wsadmin staging directory exists on DMGR
      ansible.builtin.file:
        path: "{{ was_wsadmin_stage_dir }}"
        state: directory
        mode: "0755"
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Stage wsadmin scripts to DMGR (deploy user, no root)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_wsadmin_stage_dir }}/{{ item }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    # ==========================================================================
    # Smoke test - verify deploy can su to wsadmin
    # ==========================================================================
    - name: Smoke test - verify deploy can su to wsadmin
      block:
        - name: Run su to wsadmin with id/whoami
          ansible.builtin.shell: >
            set -euo pipefail &&
            {{ was_su_wsadmin_prefix }} "id && whoami"
          args:
            executable: /bin/bash
          register: su_wsadmin_test
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

      rescue:
        - name: Collect diagnostic - deploy identity
          ansible.builtin.shell: >
            set -euo pipefail && id && whoami && groups
          args:
            executable: /bin/bash
          register: dmgr_deploy_id
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Collect diagnostic - su policy hints (best effort)
          ansible.builtin.shell: >
            set -euo pipefail &&
            (test -r /etc/pam.d/su && sed -n '1,200p' /etc/pam.d/su) || echo "cannot read /etc/pam.d/su"
          args:
            executable: /bin/bash
          register: dmgr_su_policy
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - cannot su to wsadmin
          ansible.builtin.fail:
            msg: |
              deploy cannot su to wsadmin non-interactively on DMGR host {{ was_dmgr_host }}.

              --- deploy identity ---
              {{ dmgr_deploy_id.stdout | default('') }}

              --- su policy hints ---
              {{ dmgr_su_policy.stdout | default('') }}
      run_once: true

    # ==========================================================================
    # Start DMGR (optional)
    # ==========================================================================
    - name: Start DMGR (optional; run as wsadmin)
      when: was_start_dmgr | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "{{ was_dmgr_profile }}/bin/startManager.sh"
      args:
        executable: /bin/bash
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      register: dmgr_start
      changed_when: dmgr_start.rc == 0
      failed_when: >
        dmgr_start.rc != 0 and
        ("ADMU0116I" not in (dmgr_start.stdout | default(''))) and
        ("already running" not in (dmgr_start.stdout | default('') | lower)) and
        ("already started" not in (dmgr_start.stdout | default('') | lower))
      become: false

    - name: Show DMGR start result
      when: was_start_dmgr | bool
      ansible.builtin.debug:
        msg: "DMGR start: rc={{ dmgr_start.rc | default('n/a') }}, changed={{ dmgr_start.changed | default(false) }}"
      run_once: true
      become: false

    # ==========================================================================
    # Wait for DMGR SOAP port
    # ==========================================================================
    - name: Wait for DMGR SOAP port to be reachable (local check on DMGR host)
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec }}"
        state: started
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    # ==========================================================================
    # Start nodeagent on each host (optional)
    # ==========================================================================
    - name: Start nodeagent on this host (optional; run as wsadmin)
      when: was_start_nodeagent | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "{{ was_node_profile_path }}/bin/startNode.sh"
      args:
        executable: /bin/bash
      register: nodeagent_start
      changed_when: nodeagent_start.rc == 0
      failed_when: >
        nodeagent_start.rc != 0 and
        ("ADMU0116I" not in (nodeagent_start.stdout | default(''))) and
        ("already running" not in (nodeagent_start.stdout | default('') | lower)) and
        ("already started" not in (nodeagent_start.stdout | default('') | lower))
      become: false

    - name: Show nodeagent start result
      when: was_start_nodeagent | bool
      ansible.builtin.debug:
        msg: "Nodeagent start on {{ inventory_hostname }}: rc={{ nodeagent_start.rc }}"
      become: false

    # ==========================================================================
    # Discovery - build node list and discover application servers
    # ==========================================================================
    - name: Build node list from limited hosts
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (run as wsadmin)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/discover_targets.py'
        --nodes {{ was_nodes_in_scope | join(' ') }}"
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: discovery_out.rc != 0
      become: false

    # ==========================================================================
    # Parse discovery JSON output
    # ==========================================================================
    - name: Extract JSON payload from wsadmin output (last line)
      ansible.builtin.set_fact:
        was_discovery_json_raw: "{{ discovery_out.stdout_lines | default([]) | last | default('{}') }}"
      run_once: true
      become: false

    - name: Validate JSON payload exists
      ansible.builtin.assert:
        that:
          - was_discovery_json_raw | length > 2
          - was_discovery_json_raw is match('^\\s*\\{.*\\}\\s*$')
        fail_msg: |
          wsadmin output did not contain a valid JSON object on the last line.
          Last line: {{ was_discovery_json_raw }}
          --- Full stdout (first 800 chars) ---
          {{ (discovery_out.stdout | default(''))[:800] }}
      run_once: true
      become: false

    - name: Parse discovery JSON payload
      ansible.builtin.set_fact:
        was_discovery_json: "{{ was_discovery_json_raw | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      ansible.builtin.set_fact:
        was_discovered_targets_all: "{{ was_discovery_json.targets | default([]) }}"
      run_once: true
      become: false

    - name: Filter discovered targets to nodes in scope
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true
      become: false

    - name: Fail if no targets discovered
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes {{ was_nodes_in_scope }}.
          Check was_node_name host_vars and DMGR visibility.
      run_once: true
      become: false

    - name: Show discovered targets
      ansible.builtin.debug:
        msg: "Discovered {{ was_discovered_targets | length }} application server(s): {{ was_discovered_targets | map(attribute='server') | list }}"
      run_once: true
      become: false

    # ==========================================================================
    # Start discovered application servers (one at a time)
    # ==========================================================================
    - name: Start discovered application servers (one at a time; run as wsadmin)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/control_server.py'
        --action start
        --node '{{ item.node }}'
        --server '{{ item.server }}'
        --timeout '{{ was_poll_timeout_sec }}'
        --delay '{{ was_poll_delay_sec }}'"
      args:
        executable: /bin/bash
      register: start_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: (start_out.stdout | default('')) is search('CHANGED:true')
      failed_when: start_out.rc != 0
      become: false

    - name: Show start results
      ansible.builtin.debug:
        msg: "{{ start_out.results | map(attribute='stdout_lines') | list }}"
      run_once: true
      become: false

    # ==========================================================================
    # Verify servers are running (optional)
    # ==========================================================================
    - name: Verify discovered servers are RUNNING/STARTED (optional; run as wsadmin)
      when: was_verify_after_start | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/server_state.py'
        --node '{{ item.node }}'
        --server '{{ item.server }}'"
      args:
        executable: /bin/bash
      register: verify_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: >
        verify_out.rc != 0 or
        (
          (verify_out.stdout | default('')) is not search('=RUNNING') and
          (verify_out.stdout | default('')) is not search('=STARTED')
        )
      become: false

    - name: Show verification results
      when: was_verify_after_start | bool
      ansible.builtin.debug:
        msg: "{{ verify_out.results | map(attribute='stdout') | list }}"
      run_once: true
      become: false
