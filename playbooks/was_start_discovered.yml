---
- name: Start discovered WAS application servers on limited tier hosts
  hosts: was_all_nodes
  gather_facts: false
  serial: 1
  become: true
  become_user: root
  become_method: su

  vars:
    was_run_user: "{{ was_run_user | default('wsadmin') }}"
    was_su_wsadmin_prefix: "/bin/su - {{ was_run_user }} -c"

  tasks:
    - name: Safety check â€“ require explicit approval for disruptive actions
      ansible.builtin.assert:
        that:
          - was_allow_disruptive | default(false) | bool
        fail_msg: >
          Disruptive actions are disabled.
          Set was_allow_disruptive=true (survey/extra vars) to proceed.
      run_once: true
      become: false

    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_profile_path is defined
          - was_node_profile_path | length > 0
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Ensure DMGR vars (was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass) and per-host node vars (was_node_profile_path,
          was_node_name) are set via inventory or survey.
      become: false

    - name: Stage wsadmin scripts on DMGR as deploy (no root)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "/tmp/{{ item }}"
        mode: "0644"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

      - name: Promote wsadmin scripts into DMGR profile bin (su to root via expect)
      ansible.builtin.expect:
        command: >
          /bin/su - root -c
          "install -m 0755 /tmp/discover_targets.py {{ was_dmgr_profile }}/bin/discover_targets.py &&
           install -m 0755 /tmp/server_state.py     {{ was_dmgr_profile }}/bin/server_state.py &&
           install -m 0755 /tmp/control_server.py   {{ was_dmgr_profile }}/bin/control_server.py &&
           chown {{ was_run_user | default('wsadmin') }}:{{ was_run_user | default('wsadmin') }}
             {{ was_dmgr_profile }}/bin/discover_targets.py
             {{ was_dmgr_profile }}/bin/server_state.py
             {{ was_dmgr_profile }}/bin/control_server.py"
        responses:
          (?i)password: "{{ was_root_su_password }}"
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false
      no_log: true

    - name: Ensure wsadmin owns staged scripts on DMGR
      ansible.builtin.file:
        path: "{{ was_dmgr_profile }}/bin/{{ item }}"
        owner: "{{ was_run_user }}"
        group: "{{ was_run_user }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Start DMGR (optional; run as wsadmin)
      when: was_start_dmgr | default(true) | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "{{ was_dmgr_profile }}/bin/startManager.sh"
      args:
        executable: /bin/bash
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      register: dmgr_start
      changed_when: dmgr_start.rc == 0
      failed_when: dmgr_start.rc != 0 and ("ADMU" not in (dmgr_start.stdout | default('')))

    - name: Wait for DMGR SOAP port to be reachable (local check on DMGR host)
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port | default(8879) }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec | default(300) }}"
        state: started
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Start nodeagent on each limited host (optional; run as wsadmin)
      when: was_start_nodeagent | default(true) | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "{{ was_node_profile_path }}/bin/startNode.sh"
      args:
        executable: /bin/bash
      register: nodeagent_start
      changed_when: nodeagent_start.rc == 0
      failed_when: nodeagent_start.rc != 0 and ("ADMU" not in (nodeagent_start.stdout | default('')))

    - name: Build node list from limited hosts
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (run as wsadmin)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' && ./wsadmin.sh -quiet -lang jython -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}' -f './discover_targets.py' --nodes {{ was_nodes_in_scope | join(' ') }}"
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: discovery_out.rc != 0

    - name: Extract JSON payload candidates from wsadmin output
      ansible.builtin.set_fact:
        was_discovery_json_candidates: "{{ (discovery_out.stdout | string) | regex_findall('(?s)\\{.*?\\}(?=\\s*$)') }}"
      run_once: true
      become: false

    - name: Assert JSON payload was found in wsadmin output
      ansible.builtin.assert:
        that:
          - was_discovery_json_candidates | length > 0
        fail_msg: >
          wsadmin output did not contain a trailing JSON object.
          First 800 chars:
          {{ (discovery_out.stdout | string)[:800] }}
      run_once: true
      become: false

    - name: Parse discovery JSON payload (last candidate)
      ansible.builtin.set_fact:
        was_discovery_json: "{{ (was_discovery_json_candidates | last | string) | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      ansible.builtin.set_fact:
        was_discovered_targets_all: "{{ was_discovery_json.targets | default([]) }}"
      run_once: true
      become: false

    - name: Filter discovered targets to nodes in scope
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true
      become: false

    - name: Start discovered application servers (one at a time; run as wsadmin)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' && ./wsadmin.sh -quiet -lang jython -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}' -f './control_server.py' --action start --node '{{ item.node }}' --server '{{ item.server }}' --timeout '{{ was_poll_timeout_sec | default(600) }}' --delay '{{ was_poll_delay_sec | default(5) }}'"
      args:
        executable: /bin/bash
      register: start_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: (start_out.stdout | default('')) is search('CHANGED:true')
      failed_when: start_out.rc != 0

    - name: Verify discovered servers are RUNNING/STARTED (optional; run as wsadmin)
      when: was_verify_after_start | default(true) | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' && ./wsadmin.sh -quiet -lang jython -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}' -f './server_state.py' --node '{{ item.node }}' --server '{{ item.server }}'"
      args:
        executable: /bin/bash
      register: verify_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: >
        verify_out.rc != 0 or
        (
          (verify_out.stdout | default('')) is not search('=RUNNING') and
          (verify_out.stdout | default('')) is not search('=STARTED')
        )
