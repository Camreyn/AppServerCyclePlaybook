---
- name: Preflight WAS stop/start (discovery + access checks, no changes)
  hosts: was_all_nodes
  gather_facts: false

  vars:
    was_preflight_fail_if_no_targets: true

  tasks:
    - name: Show which hosts are in scope (AAP limit)
      ansible.builtin.debug:
        msg:
          - "ansible_play_hosts={{ ansible_play_hosts }}"
          - "inventory_hostname={{ inventory_hostname }}"
      run_once: true

    - name: Validate required DMGR vars
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
        fail_msg: >
          Missing required DMGR variables.
          Ensure was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, and was_wsadmin_pass are set
          via inventory or survey.
      run_once: true

    - name: Validate required node vars
      ansible.builtin.assert:
        that:
          - was_node_profile_path is defined
          - was_node_profile_path | length > 0
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required node variables on {{ inventory_hostname }}.
          Ensure was_node_profile_path and was_node_name are set.

    - name: Check node profile bin exists (no execution)
      ansible.builtin.stat:
        path: "{{ was_node_profile_path }}/bin"
      register: node_bin_stat

    - name: Assert node profile bin exists
      ansible.builtin.assert:
        that:
          - node_bin_stat.stat.exists
          - node_bin_stat.stat.isdir
        fail_msg: "Missing node profile bin on {{ inventory_hostname }}: {{ was_node_profile_path }}/bin"

    - name: Check startNode.sh exists
      ansible.builtin.stat:
        path: "{{ was_node_profile_path }}/bin/startNode.sh"
      register: startnode_stat

    - name: Check stopNode.sh exists
      ansible.builtin.stat:
        path: "{{ was_node_profile_path }}/bin/stopNode.sh"
      register: stopnode_stat

    - name: Assert nodeagent scripts exist
      ansible.builtin.assert:
        that:
          - startnode_stat.stat.exists
          - stopnode_stat.stat.exists
        fail_msg: >
          Missing startNode.sh or stopNode.sh under
          {{ was_node_profile_path }}/bin on {{ inventory_hostname }}

    - name: Check DMGR wsadmin.sh exists
      ansible.builtin.stat:
        path: "{{ was_dmgr_profile }}/bin/wsadmin.sh"
      register: dmgr_wsadmin_stat
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Assert wsadmin.sh exists on DMGR
      ansible.builtin.assert:
        that:
          - dmgr_wsadmin_stat.stat.exists
        fail_msg: "wsadmin.sh not found at {{ was_dmgr_profile }}/bin/wsadmin.sh"
      run_once: true

    - name: Stage wsadmin scripts to DMGR (safe)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_dmgr_profile }}/bin/{{ item }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Build node list from limited hosts
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true

    - name: Discover application servers via DMGR (safe)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./discover_targets.py"
        --nodes {{ was_nodes_in_scope | join(' ') }}
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: discovery_out.rc != 0

    - name: Parse discovery JSON
      ansible.builtin.set_fact:
        was_discovery_json: "{{ discovery_out.stdout | trim | from_json }}"
      run_once: true

    - name: Parse discovered targets
      ansible.builtin.set_fact: { was_discovered_targets_all: "{{ was_discovery_json['targets'] | default([]) }}" }
      run_once: true

    - name: Filter discovered targets to nodes in scope
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true

    - name: Fail if no targets found (optional)
      when: was_preflight_fail_if_no_targets | bool
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes
          {{ was_nodes_in_scope }}.
      run_once: true

    - name: Show what would be stopped/started
      ansible.builtin.debug:
        var: was_discovered_targets
      run_once: true

    - name: Query runtime state for each discovered server (safe)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./server_state.py"
        --node "{{ item.node }}"
        --server "{{ item.server }}"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: state_out.rc != 0

    - name: Summarize server states
      ansible.builtin.debug:
        msg: "{{ state_out.results | map(attribute='stdout') | list }}"
      run_once: true
