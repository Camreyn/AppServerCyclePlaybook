---
- name: Validate discovered WAS/BAW servers (wsadmin discovery + state + idempotent probes)
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  become: true
  become_user: "{{ was_run_user | default('wsadmin') }}"
  become_method: su

  vars:
    was_smoketest_allow_changes: false

  tasks:
    - name: Show which hosts are in scope (AAP limit)
      ansible.builtin.debug:
        msg:
          - "ansible_play_hosts={{ ansible_play_hosts }}"
          - "was_dmgr_host={{ was_dmgr_host | default('UNSET') }}"
          - "was_dmgr_profile={{ was_dmgr_profile | default('UNSET') }}"
      run_once: true
      become: false

    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_profile_path is defined
          - was_node_profile_path | length > 0
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Ensure DMGR vars (was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass) and per-host node vars (was_node_profile_path,
          was_node_name) are set via inventory or survey.
      become: false

    - name: Stage wsadmin scripts to DMGR (run as wsadmin)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_dmgr_profile }}/bin/{{ item }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Wait for DMGR SOAP port to be reachable (local check on DMGR host)
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port | default(8879) }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec | default(300) }}"
        state: started
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Build node list from limited hosts
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (safe)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./discover_targets.py"
        --nodes {{ was_nodes_in_scope | join(' ') }}
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: discovery_out.rc != 0

    - name: Extract JSON payload candidates from wsadmin output
      ansible.builtin.set_fact:
        was_discovery_json_candidates: "{{ (discovery_out.stdout | string) | regex_findall('(?s)\\{.*?\\}(?=\\s*$)') }}"
      run_once: true
      become: false

    - name: Assert JSON payload was found in wsadmin output
      ansible.builtin.assert:
        that:
          - was_discovery_json_candidates | length > 0
        fail_msg: >
          wsadmin output did not contain a trailing JSON object.
          First 800 chars:
          {{ (discovery_out.stdout | string)[:800] }}
      run_once: true
      become: false

    - name: Parse discovery JSON payload (last candidate)
      ansible.builtin.set_fact:
        was_discovery_json: "{{ (was_discovery_json_candidates | last | string) | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            (was_discovery_json.targets | default([]))
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true
      become: false

    - name: Fail if discovery returns zero targets
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes {{ was_nodes_in_scope }}.
          Check was_node_name host_vars and DMGR visibility.
      run_once: true
      become: false

    - name: Query runtime state for each discovered server (safe)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./server_state.py"
        --node "{{ item.node }}"
        --server "{{ item.server }}"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: state_out.rc != 0

    - name: Initialize state lists
      ansible.builtin.set_fact:
        was_running_targets: []
        was_down_targets: []
        was_unknown_targets: []
      run_once: true
      become: false

    - name: Classify RUNNING/STARTED targets
      ansible.builtin.set_fact:
        was_running_targets: "{{ was_running_targets + [ item.item ] }}"
      when: (item.stdout | default('')) is search('=(RUNNING|STARTED)\\b')
      loop: "{{ state_out.results }}"
      loop_control:
        label: "{{ item.item.node }}/{{ item.item.server }}"
      run_once: true
      become: false

    - name: Classify STOPPED/NOT_FOUND targets
      ansible.builtin.set_fact:
        was_down_targets: "{{ was_down_targets + [ item.item ] }}"
      when: (item.stdout | default('')) is search('=(STOPPED|NOT_FOUND)\\b')
      loop: "{{ state_out.results }}"
      loop_control:
        label: "{{ item.item.node }}/{{ item.item.server }}"
      run_once: true
      become: false

    - name: Classify UNKNOWN targets
      ansible.builtin.set_fact:
        was_unknown_targets: "{{ was_unknown_targets + [ item.item ] }}"
      when: >
        (item.stdout | default('')) is not search('=(RUNNING|STARTED)\\b') and
        (item.stdout | default('')) is not search('=(STOPPED|NOT_FOUND)\\b')
      loop: "{{ state_out.results }}"
      loop_control:
        label: "{{ item.item.node }}/{{ item.item.server }}"
      run_once: true
      become: false

    - name: Probe START on already-running targets (should not change anything)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./control_server.py"
        --action start
        --node "{{ item.node }}"
        --server "{{ item.server }}"
        --timeout "{{ was_poll_timeout_sec | default(600) }}"
        --delay "{{ was_poll_delay_sec | default(5) }}"
      args:
        executable: /bin/bash
      register: start_probe_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_running_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: start_probe_out.rc != 0

    - name: Probe STOP on already-down targets (should not change anything)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./control_server.py"
        --action stop
        --node "{{ item.node }}"
        --server "{{ item.server }}"
        --timeout "{{ was_poll_timeout_sec | default(600) }}"
        --delay "{{ was_poll_delay_sec | default(5) }}"
      args:
        executable: /bin/bash
      register: stop_probe_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_down_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: stop_probe_out.rc != 0

    - name: Fail if any probe indicates a real change (safety latch)
      when: not (was_smoketest_allow_changes | default(false) | bool)
      ansible.builtin.assert:
        that:
          - (start_probe_out.results | default([]) | selectattr('stdout', 'search', 'CHANGED:true') | list | length) == 0
          - (stop_probe_out.results  | default([]) | selectattr('stdout', 'search', 'CHANGED:true') | list | length) == 0
        fail_msg: >
          Validate run detected CHANGED:true during probes.
          If you intended to allow changes, set was_smoketest_allow_changes=true.
      run_once: true
      become: false
