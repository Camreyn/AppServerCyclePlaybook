---
- name: Validate discovered WAS/BAW servers (branching diagnostics + fast skip)
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  vars:
    # OS user that should run wsadmin.sh
    was_run_user: "wsadmin"

    # Where we stage Jython scripts on the DMGR host (no root required)
    was_wsadmin_stage_dir: "/tmp/was_wsadmin_scripts"

    # How long to wait for DMGR SOAP (if enabled)
    was_dmgr_soap_port: "8879"
    was_dmgr_soap_wait_timeout_sec: "120"

    # If DMGR SOAP isn't reachable, collect diagnostics and fail fast (skip discovery/probes)
    was_fail_fast_on_dmgr_unreachable: true

    # Skip discovery/probes if we already know DMGR isn't healthy
    was_skip_on_dmgr_issue: true

    # Wrapper: run a command as wsadmin (no Ansible become required)
    was_su_wsadmin_prefix: "/bin/su - {{ was_run_user }} -c"

    # If false, probes must not cause changes (idempotency check)
    was_smoketest_allow_changes: false

  tasks:
    # ------------------------------------------------------------
    # 0) Validate required vars early
    # ------------------------------------------------------------
    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Need was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass, and per-host was_node_name.
      become: false

    # ------------------------------------------------------------
    # 1) DMGR prechecks (branching diagnostics)
    # ------------------------------------------------------------
    - name: DMGR precheck - ensure wsadmin.sh exists
      ansible.builtin.stat:
        path: "{{ was_dmgr_profile }}/bin/wsadmin.sh"
      register: dmgr_wsadmin_stat
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: DMGR diag - collect profile listing when wsadmin.sh missing
      when: not dmgr_wsadmin_stat.stat.exists
      block:
        - name: DMGR diag - list DMGR bin directory
          ansible.builtin.shell: >
            set -euo pipefail &&
            ls -la "{{ was_dmgr_profile }}/bin" || true
          args:
            executable: /bin/bash
          register: dmgr_bin_ls
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - show filesystem and permissions
          ansible.builtin.shell: >
            set -euo pipefail &&
            id && whoami &&
            ls -ld "{{ was_dmgr_profile }}" "{{ was_dmgr_profile }}/bin" || true
          args:
            executable: /bin/bash
          register: dmgr_perm_diag
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - wsadmin.sh missing on DMGR
          ansible.builtin.fail:
            msg: |
              wsadmin.sh not found at {{ was_dmgr_profile }}/bin/wsadmin.sh on DMGR host {{ was_dmgr_host }}.
              --- ls -la bin ---
              {{ dmgr_bin_ls.stdout | default('') }}
              {{ dmgr_bin_ls.stderr | default('') }}
              --- perms/id ---
              {{ dmgr_perm_diag.stdout | default('') }}
              {{ dmgr_perm_diag.stderr | default('') }}
      run_once: true

    - name: DMGR precheck - ensure staging dir exists (deploy user)
      ansible.builtin.file:
        path: "{{ was_wsadmin_stage_dir }}"
        state: directory
        mode: "0755"
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: DMGR precheck - stage wsadmin scripts to DMGR staging dir (deploy user)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_wsadmin_stage_dir }}/{{ item }}"
        mode: "0644"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: DMGR precheck - SOAP port reachable from DMGR host
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec }}"
        state: started
      register: dmgr_soap_wait
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false
      failed_when: false
      changed_when: false

    - name: Set DMGR health flags
      ansible.builtin.set_fact:
        was_dmgr_soap_reachable: "{{ (dmgr_soap_wait is not failed) and (dmgr_soap_wait.state is defined) and (dmgr_soap_wait.state == 'started') }}"
      run_once: true
      become: false

    - name: DMGR diag - collect diagnostics when SOAP is not reachable
      when: not was_dmgr_soap_reachable
      block:
        - name: DMGR diag - netstat/ss for SOAP port
          ansible.builtin.shell: >
            set -euo pipefail &&
            (command -v ss >/dev/null 2>&1 && ss -ltnp | grep -E '(:{{ was_dmgr_soap_port }}\s)') ||
            (command -v netstat >/dev/null 2>&1 && netstat -ltnp 2>/dev/null | grep -E '(:{{ was_dmgr_soap_port }}\s)') ||
            echo "No ss/netstat output for port {{ was_dmgr_soap_port }} (or tools missing)."
          args:
            executable: /bin/bash
          register: dmgr_port_diag
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - tail wsadmin.traceout (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 120 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_wsadmin_trace_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - tail SystemOut.log (dmgr) (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/dmgr/SystemOut.log" &&
            if [ -f "$f" ]; then tail -n 160 "$f"; else echo "No SystemOut.log at $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_sysout_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - tail SystemErr.log (dmgr) (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/dmgr/SystemErr.log" &&
            if [ -f "$f" ]; then tail -n 160 "$f"; else echo "No SystemErr.log at $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_syserr_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - attempt wsadmin connection (expected to fail; capture)
          ansible.builtin.shell: >
            set -euo pipefail &&
            {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
            ./wsadmin.sh -quiet -lang jython
            -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
            -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
            -c 'print \"CONNECTED_OK\"' " || true
          args:
            executable: /bin/bash
          register: dmgr_wsadmin_connect_attempt
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail fast - DMGR SOAP not reachable
          when: was_fail_fast_on_dmgr_unreachable | bool
          ansible.builtin.fail:
            msg: |
              DMGR SOAP port {{ was_dmgr_soap_port }} NOT reachable on {{ was_dmgr_host }} (localhost).
              Skipping discovery/probes.
              --- Port listeners ---
              {{ dmgr_port_diag.stdout | default('') }}
              {{ dmgr_port_diag.stderr | default('') }}
              --- wsadmin.traceout tail ---
              {{ dmgr_wsadmin_trace_tail.stdout | default('') }}
              {{ dmgr_wsadmin_trace_tail.stderr | default('') }}
              --- dmgr/SystemOut.log tail ---
              {{ dmgr_sysout_tail.stdout | default('') }}
              {{ dmgr_sysout_tail.stderr | default('') }}
              --- dmgr/SystemErr.log tail ---
              {{ dmgr_syserr_tail.stdout | default('') }}
              {{ dmgr_syserr_tail.stderr | default('') }}
              --- wsadmin connect attempt (captured) ---
              {{ dmgr_wsadmin_connect_attempt.stdout | default('') }}
              {{ dmgr_wsadmin_connect_attempt.stderr | default('') }}
      run_once: true

    - name: Set skip flag for downstream steps
      ansible.builtin.set_fact:
        was_skip_discovery_and_probes: "{{ (was_skip_on_dmgr_issue | bool) and (not was_dmgr_soap_reachable) }}"
      run_once: true
      become: false

    # ------------------------------------------------------------
    # 2) Discovery (skipped if DMGR unhealthy)
    # ------------------------------------------------------------
    - name: Build node list from limited hosts
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (run as wsadmin; script from staging dir)
      when: not was_skip_discovery_and_probes
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host {{ was_dmgr_host }} -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/discover_targets.py'
        --nodes {{ was_nodes_in_scope | join(' ') }}"
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    - name: Discovery diag - show stdout/stderr if wsadmin failed
      when: not was_skip_discovery_and_probes and discovery_out.rc != 0
      block:
        - name: Capture discovery stdout/stderr
          ansible.builtin.debug:
            msg: |
              Discovery failed rc={{ discovery_out.rc }}
              --- stdout ---
              {{ discovery_out.stdout | default('') }}
              --- stderr ---
              {{ discovery_out.stderr | default('') }}
          run_once: true

        - name: Tail wsadmin.traceout after discovery failure (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 180 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_discovery
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - discovery failed
          ansible.builtin.fail:
            msg: |
              Discover application servers via DMGR failed.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_discovery.stdout | default('') }}
              {{ wsadmin_trace_after_discovery.stderr | default('') }}
      run_once: true

    - name: Extract JSON payload candidates from wsadmin output
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovery_json_candidates: "{{ (discovery_out.stdout | string) | regex_findall('(?s)\\{.*?\\}(?=\\s*$)') }}"
      run_once: true
      become: false

    - name: Discovery diag - when JSON payload missing
      when: not was_skip_discovery_and_probes and (was_discovery_json_candidates | length) == 0
      block:
        - name: Show discovery output head/tail
          ansible.builtin.debug:
            msg: |
              wsadmin output did not contain a trailing JSON object.
              --- first 800 chars ---
              {{ (discovery_out.stdout | string)[:800] }}
              --- last 800 chars ---
              {{ (discovery_out.stdout | string)[-800:] }}
          run_once: true

        - name: Tail wsadmin.traceout after JSON-missing (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 180 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_json_missing
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - JSON payload missing
          ansible.builtin.fail:
            msg: |
              wsadmin output missing JSON payload.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_json_missing.stdout | default('') }}
              {{ wsadmin_trace_after_json_missing.stderr | default('') }}
      run_once: true

    - name: Parse discovery JSON payload (last candidate)
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovery_json: "{{ (was_discovery_json_candidates | last | string) | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovered_targets_all: "{{ was_discovery_json.targets | default([]) }}"
      run_once: true
      become: false

    - name: Filter discovered targets to nodes in scope
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true
      become: false

    - name: Fail if discovery returns zero targets
      when: not was_skip_discovery_and_probes
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes {{ was_nodes_in_scope }}.
          Check was_node_name host_vars and DMGR visibility.
      run_once: true
      become: false

    # ------------------------------------------------------------
    # 3) State checks + probes (skipped if DMGR unhealthy)
    # ------------------------------------------------------------
    - name: Query runtime state for each discovered server (run as wsadmin)
      when: not was_skip_discovery_and_probes
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/server_state.py'
        --node '{{ item.node }}'
        --server '{{ item.server }}'"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    - name: State diag - fail if any state query failed (collect traceout)
      when: not was_skip_discovery_and_probes and (state_out.results | selectattr('rc', 'ne', 0) | list | length) > 0
      block:
        - name: Show failed state query results
          ansible.builtin.debug:
            var: state_out.results
          run_once: true

        - name: Tail wsadmin.traceout after state failures (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 220 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_state
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - state query failures
          ansible.builtin.fail:
            msg: |
              One or more server_state.py queries failed.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_state.stdout | default('') }}
              {{ wsadmin_trace_after_state.stderr | default('') }}
      run_once: true

    - name: Summarize current states
      when: not was_skip_discovery_and_probes
      ansible.builtin.debug:
        msg: "{{ state_out.results | map(attribute='stdout') | list }}"
      run_once: true
      become: false

    # Optional idempotency probes (safe) --------------------------------
    - name: Probe START on already-running targets (should not change)
      when: not was_skip_discovery_and_probes and (was_verify_after_start | default(true) | bool)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/control_server.py'
        --action start --node '{{ item.node }}' --server '{{ item.server }}'
        --timeout '{{ was_poll_timeout_sec | default(600) }}'
        --delay '{{ was_poll_delay_sec | default(5) }}'"
      args:
        executable: /bin/bash
      register: start_probe_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    - name: Probe diag - if any probe failed, collect traceout and fail
      when: not was_skip_discovery_and_probes and (start_probe_out.results | selectattr('rc', 'ne', 0) | list | length) > 0
      block:
        - name: Show probe failures
          ansible.builtin.debug:
            var: start_probe_out.results
          run_once: true

        - name: Tail wsadmin.traceout after probe failures (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 260 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_probe
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - probe failures
          ansible.builtin.fail:
            msg: |
              One or more control_server.py probes failed.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_probe.stdout | default('') }}
              {{ wsadmin_trace_after_probe.stderr | default('') }}
      run_once: true
