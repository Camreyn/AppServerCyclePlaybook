---
- name: Validate discovered WAS/BAW servers (branching diagnostics + fast skip)
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  vars:
    # OS user that should run wsadmin.sh
    was_run_user: "wsadmin"

    # Where we stage Jython scripts on the DMGR host (no root required)
    was_wsadmin_stage_dir: "/tmp/was_wsadmin_scripts"

    # How long to wait for DMGR SOAP (if enabled)
    was_dmgr_soap_port: "8879"
    was_dmgr_soap_wait_timeout_sec: "120"

    # If DMGR SOAP isn't reachable, collect diagnostics and fail fast (skip discovery/probes)
    was_fail_fast_on_dmgr_unreachable: true

    # Skip discovery/probes if we already know DMGR isn't healthy
    was_skip_on_dmgr_issue: true

    # Wrapper: run a command as wsadmin (no Ansible become required)
    was_su_wsadmin_prefix: "/bin/su - {{ was_run_user }} -c"

    # If false, probes must not cause changes (idempotency check)
    was_smoketest_allow_changes: false

    # New: If deploy cannot su to wsadmin reliably, branch diagnostics and skip discovery/probes
    was_skip_on_su_wsadmin_failure: true

  tasks:
    # ------------------------------------------------------------
    # 0) Validate required vars early
    # ------------------------------------------------------------
    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Need was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass, and per-host was_node_name.
      become: false

    # ------------------------------------------------------------
    # 1) DMGR prechecks (branching diagnostics)
    # ------------------------------------------------------------
    - name: DMGR precheck - ensure wsadmin.sh exists
      ansible.builtin.stat:
        path: "{{ was_dmgr_profile }}/bin/wsadmin.sh"
      register: dmgr_wsadmin_stat
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: DMGR diag - collect profile listing when wsadmin.sh missing
      when: not dmgr_wsadmin_stat.stat.exists
      block:
        - name: DMGR diag - list DMGR bin directory
          ansible.builtin.shell: >
            set -euo pipefail &&
            ls -la "{{ was_dmgr_profile }}/bin" || true
          args:
            executable: /bin/bash
          register: dmgr_bin_ls
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - show filesystem and permissions
          ansible.builtin.shell: >
            set -euo pipefail &&
            id && whoami &&
            ls -ld "{{ was_dmgr_profile }}" "{{ was_dmgr_profile }}/bin" || true
          args:
            executable: /bin/bash
          register: dmgr_perm_diag
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - wsadmin.sh missing on DMGR
          ansible.builtin.fail:
            msg: |
              wsadmin.sh not found at {{ was_dmgr_profile }}/bin/wsadmin.sh on DMGR host {{ was_dmgr_host }}.
              --- ls -la bin ---
              {{ dmgr_bin_ls.stdout | default('') }}
              {{ dmgr_bin_ls.stderr | default('') }}
              --- perms/id ---
              {{ dmgr_perm_diag.stdout | default('') }}
              {{ dmgr_perm_diag.stderr | default('') }}
      run_once: true

    - name: DMGR precheck - ensure staging dir exists (deploy user)
      ansible.builtin.file:
        path: "{{ was_wsadmin_stage_dir }}"
        state: directory
        mode: "0755"
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: DMGR precheck - stage wsadmin scripts to DMGR staging dir (deploy user)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_wsadmin_stage_dir }}/{{ item }}"
        mode: "0644"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    # ------------------------------------------------------------
    # 1.5) NEW: Smoke test su-to-wsadmin on DMGR host
    # If this fails, we collect diagnostics and skip discovery/probes
    # ------------------------------------------------------------
    - name: DMGR smoke test - can deploy su to wsadmin (non-disruptive)
      block:
        - name: su to wsadmin and run id/whoami
          ansible.builtin.shell: >
            set -euo pipefail &&
            {{ was_su_wsadmin_prefix | quote }} "id && whoami"
          args:
            executable: /bin/bash
          register: su_wsadmin_test
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Mark su-to-wsadmin OK
          ansible.builtin.set_fact:
            was_can_su_to_wsadmin: true
          run_once: true
          become: false

      rescue:
        - name: Mark su-to-wsadmin FAILED
          ansible.builtin.set_fact:
            was_can_su_to_wsadmin: false
          run_once: true
          become: false

        - name: DMGR diag - deploy identity
          ansible.builtin.shell: >
            set -euo pipefail && id && whoami && groups
          args:
            executable: /bin/bash
          register: dmgr_deploy_id
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - su policy hints (best effort)
          ansible.builtin.shell: >
            set -euo pipefail &&
            (test -r /etc/pam.d/su && sed -n '1,200p' /etc/pam.d/su) || echo "cannot read /etc/pam.d/su" &&
            echo "----" &&
            (test -r /etc/login.defs && grep -E '^(SU_|SULOG|ENV_SUPATH|ENV_PATH)' /etc/login.defs || true)
          args:
            executable: /bin/bash
          register: dmgr_su_policy
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - tail /var/log/secure (best effort)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="/var/log/secure" &&
            if [ -r "$f" ]; then tail -n 120 "$f"; else echo "No readable $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_secure_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail fast (cannot su to wsadmin) or skip later steps
          when: not was_skip_on_su_wsadmin_failure | bool
          ansible.builtin.fail:
            msg: |
              deploy cannot su to wsadmin non-interactively on DMGR host {{ was_dmgr_host }}.
              This often manifests in AAP as: "Shared connection ... closed".
              Fix options:
              - Allow deploy -> su - wsadmin without interactive restrictions on DMGR hosts, OR
              - Use SSH as wsadmin for DMGR hosts (separate credential), OR
              - Restore deploy -> su root -> su wsadmin flow with working escalation.

              --- deploy identity ---
              {{ dmgr_deploy_id.stdout | default('') }}
              {{ dmgr_deploy_id.stderr | default('') }}

              --- su policy hints ---
              {{ dmgr_su_policy.stdout | default('') }}
              {{ dmgr_su_policy.stderr | default('') }}

              --- /var/log/secure tail ---
              {{ dmgr_secure_tail.stdout | default('') }}
              {{ dmgr_secure_tail.stderr | default('') }}
      run_once: true

    - name: Set skip flag for downstream steps (su-to-wsadmin failure)
      ansible.builtin.set_fact:
        was_skip_due_to_su_wsadmin: "{{ was_skip_on_su_wsadmin_failure | bool and (not (was_can_su_to_wsadmin | default(false) | bool)) }}"
      run_once: true
      become: false

    # ------------------------------------------------------------
    # SOAP reachability (only if su-to-wsadmin works)
    # ------------------------------------------------------------
    - name: DMGR precheck - SOAP port reachable from DMGR host
      when: not was_skip_due_to_su_wsadmin
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec }}"
        state: started
      register: dmgr_soap_wait
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false
      failed_when: false
      changed_when: false

    - name: Set DMGR health flags
      when: not was_skip_due_to_su_wsadmin
      ansible.builtin.set_fact:
        was_dmgr_soap_reachable: "{{ (dmgr_soap_wait is not failed) and (dmgr_soap_wait.state is defined) and (dmgr_soap_wait.state == 'started') }}"
      run_once: true
      become: false

    - name: DMGR diag - collect diagnostics when SOAP is not reachable
      when: not was_skip_due_to_su_wsadmin and (not was_dmgr_soap_reachable)
      block:
        - name: DMGR diag - netstat/ss for SOAP port
          ansible.builtin.shell: >
            set -euo pipefail &&
            (command -v ss >/dev/null 2>&1 && ss -ltnp | grep -E '(:{{ was_dmgr_soap_port }}\s)') ||
            (command -v netstat >/dev/null 2>&1 && netstat -ltnp 2>/dev/null | grep -E '(:{{ was_dmgr_soap_port }}\s)') ||
            echo "No ss/netstat output for port {{ was_dmgr_soap_port }} (or tools missing)."
          args:
            executable: /bin/bash
          register: dmgr_port_diag
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - tail wsadmin.traceout (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 120 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_wsadmin_trace_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - attempt wsadmin connection (expected to fail; capture)
          ansible.builtin.shell: >
            set -euo pipefail &&
            {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
            ./wsadmin.sh -quiet -lang jython
            -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
            -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
            -c 'print \"CONNECTED_OK\"' " || true
          args:
            executable: /bin/bash
          register: dmgr_wsadmin_connect_attempt
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail fast - DMGR SOAP not reachable
          when: was_fail_fast_on_dmgr_unreachable | bool
          ansible.builtin.fail:
            msg: |
              DMGR SOAP port {{ was_dmgr_soap_port }} NOT reachable on {{ was_dmgr_host }} (localhost).
              Skipping discovery/probes.
              --- Port listeners ---
              {{ dmgr_port_diag.stdout | default('') }}
              {{ dmgr_port_diag.stderr | default('') }}
              --- wsadmin.traceout tail ---
              {{ dmgr_wsadmin_trace_tail.stdout | default('') }}
              {{ dmgr_wsadmin_trace_tail.stderr | default('') }}
              --- wsadmin connect attempt (captured) ---
              {{ dmgr_wsadmin_connect_attempt.stdout | default('') }}
              {{ dmgr_wsadmin_connect_attempt.stderr | default('') }}
      run_once: true

    - name: Set skip flag for downstream steps (DMGR health)
      ansible.builtin.set_fact:
        was_skip_discovery_and_probes: >-
          {{
            was_skip_due_to_su_wsadmin
            or
            ((was_skip_on_dmgr_issue | bool) and (not (was_dmgr_soap_reachable | default(false) | bool)))
          }}
      run_once: true
      become: false

    # ------------------------------------------------------------
    # 2) Discovery (skipped if DMGR unhealthy OR su-to-wsadmin fails)
    # ------------------------------------------------------------
    - name: Build node list from limited hosts
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (run as wsadmin; script from staging dir)
      when: not was_skip_discovery_and_probes
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host {{ was_dmgr_host }} -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/discover_targets.py'
        --nodes {{ was_nodes_in_scope | join(' ') }}"
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    # ------------------------ remainder unchanged ------------------------
    # Keep the rest of your tasks exactly as-is below this point.
    # --------------------------------------------------------------------
    - name: Discovery diag - show stdout/stderr if wsadmin failed
      when: not was_skip_discovery_and_probes and discovery_out.rc != 0
      block:
        - name: Capture discovery stdout/stderr
          ansible.builtin.debug:
            msg: |
              Discovery failed rc={{ discovery_out.rc }}
              --- stdout ---
              {{ discovery_out.stdout | default('') }}
              --- stderr ---
              {{ discovery_out.stderr | default('') }}
          run_once: true

        - name: Tail wsadmin.traceout after discovery failure (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 180 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_discovery
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - discovery failed
          ansible.builtin.fail:
            msg: |
              Discover application servers via DMGR failed.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_discovery.stdout | default('') }}
              {{ wsadmin_trace_after_discovery.stderr | default('') }}
      run_once: true

    - name: Extract JSON payload candidates from wsadmin output
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovery_json_candidates: "{{ (discovery_out.stdout | string) | regex_findall('(?s)\\{.*?\\}(?=\\s*$)') }}"
      run_once: true
      become: false

    - name: Discovery diag - when JSON payload missing
      when: not was_skip_discovery_and_probes and (was_discovery_json_candidates | length) == 0
      block:
        - name: Show discovery output head/tail
          ansible.builtin.debug:
            msg: |
              wsadmin output did not contain a trailing JSON object.
              --- first 800 chars ---
              {{ (discovery_out.stdout | string)[:800] }}
              --- last 800 chars ---
              {{ (discovery_out.stdout | string)[-800:] }}
          run_once: true

        - name: Tail wsadmin.traceout after JSON-missing (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 180 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_json_missing
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - JSON payload missing
          ansible.builtin.fail:
            msg: |
              wsadmin output missing JSON payload.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_json_missing.stdout | default('') }}
              {{ wsadmin_trace_after_json_missing.stderr | default('') }}
      run_once: true

    - name: Parse discovery JSON payload (last candidate)
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovery_json: "{{ (was_discovery_json_candidates | last | string) | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovered_targets_all: "{{ was_discovery_json.targets | default([]) }}"
      run_once: true
      become: false

    - name: Filter discovered targets to nodes in scope
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true
      become: false

    - name: Fail if discovery returns zero targets
      when: not was_skip_discovery_and_probes
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes {{ was_nodes_in_scope }}.
          Check was_node_name host_vars and DMGR visibility.
      run_once: true
      become: false

    - name: Query runtime state for each discovered server (run as wsadmin)
      when: not was_skip_discovery_and_probes
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/server_state.py'
        --node '{{ item.node }}'
        --server '{{ item.server }}'"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    - name: Summarize current states
      when: not was_skip_discovery_and_probes
      ansible.builtin.debug:
        msg: "{{ state_out.results | map(attribute='stdout') | list }}"
      run_once: true
      become: false
