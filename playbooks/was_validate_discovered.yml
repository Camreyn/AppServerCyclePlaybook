---
# =============================================================================
# was_validate_discovered.yml
# Validate WAS/BAW environment readiness (non-disruptive pre-flight check)
#
# This playbook validates:
#   1. Required variables are defined
#   2. wsadmin.sh exists on DMGR
#   3. deploy user can su to wsadmin user (critical for BAW environments)
#   4. DMGR SOAP port is reachable
#   5. Application servers can be discovered
#   6. Server states can be queried
#
# This playbook does NOT start, stop, or modify anything.
# It's safe to run at any time to verify environment readiness.
#
# Required variables:
#   - was_dmgr_host: DMGR hostname (delegate target)
#   - was_dmgr_profile: Path to DMGR profile
#   - was_wsadmin_user: wsadmin SOAP authentication user
#   - was_wsadmin_pass: wsadmin SOAP authentication password
#   - was_node_name: Per-host WebSphere node name
#
# Optional variables:
#   - was_run_user: OS user to run wsadmin as (default: wsadmin)
#   - was_dmgr_soap_port: DMGR SOAP port (default: 8879)
#   - was_dmgr_soap_wait_timeout_sec: Timeout waiting for SOAP port (default: 120)
#   - was_fail_fast_on_dmgr_unreachable: Fail immediately if DMGR SOAP unreachable (default: true)
#   - was_skip_on_su_wsadmin_failure: Skip discovery if su fails (default: true)
# =============================================================================

- name: Validate discovered WAS/BAW servers (non-disruptive pre-flight check)
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  vars:
    # OS user that should run wsadmin.sh
    was_run_user: "{{ was_run_user | default('wsadmin') }}"

    # Wrapper: run a command as wsadmin (no Ansible become required)
    was_su_wsadmin_prefix: "/bin/su - {{ was_run_user }} -c"

    # Where we stage Jython scripts on the DMGR host (no root required)
    was_wsadmin_stage_dir: "/tmp/was_wsadmin_scripts"

    # DMGR SOAP configuration
    was_dmgr_soap_port: "{{ was_dmgr_soap_port | default(8879) }}"
    was_dmgr_soap_wait_timeout_sec: "{{ was_dmgr_soap_wait_timeout_sec | default(120) }}"

    # Behavior flags
    was_fail_fast_on_dmgr_unreachable: "{{ was_fail_fast_on_dmgr_unreachable | default(true) }}"
    was_skip_on_su_wsadmin_failure: "{{ was_skip_on_su_wsadmin_failure | default(true) }}"

  tasks:
    # ==========================================================================
    # 1) Validate required variables
    # ==========================================================================
    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Need was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass, and per-host was_node_name.
      become: false

    # ==========================================================================
    # 2) DMGR pre-checks - verify wsadmin.sh exists
    # ==========================================================================
    - name: DMGR precheck - ensure wsadmin.sh exists
      ansible.builtin.stat:
        path: "{{ was_dmgr_profile }}/bin/wsadmin.sh"
      register: dmgr_wsadmin_stat
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: DMGR diag - collect diagnostics when wsadmin.sh missing
      when: not dmgr_wsadmin_stat.stat.exists
      block:
        - name: DMGR diag - list DMGR bin directory
          ansible.builtin.shell: >
            set -euo pipefail &&
            ls -la "{{ was_dmgr_profile }}/bin" 2>&1 || echo "Directory not accessible"
          args:
            executable: /bin/bash
          register: dmgr_bin_ls
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: DMGR diag - show filesystem and permissions
          ansible.builtin.shell: >
            set -euo pipefail &&
            id && whoami &&
            ls -ld "{{ was_dmgr_profile }}" "{{ was_dmgr_profile }}/bin" 2>&1 || true
          args:
            executable: /bin/bash
          register: dmgr_perm_diag
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - wsadmin.sh missing on DMGR
          ansible.builtin.fail:
            msg: |
              wsadmin.sh not found at {{ was_dmgr_profile }}/bin/wsadmin.sh on DMGR host {{ was_dmgr_host }}.
              --- ls -la bin ---
              {{ dmgr_bin_ls.stdout | default('') }}
              {{ dmgr_bin_ls.stderr | default('') }}
              --- perms/id ---
              {{ dmgr_perm_diag.stdout | default('') }}
              {{ dmgr_perm_diag.stderr | default('') }}
      run_once: true

    # ==========================================================================
    # 3) Stage wsadmin scripts to /tmp (no root required)
    # ==========================================================================
    - name: Ensure wsadmin staging directory exists on DMGR
      ansible.builtin.file:
        path: "{{ was_wsadmin_stage_dir }}"
        state: directory
        mode: "0755"
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Stage wsadmin scripts to DMGR (deploy user, no root)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_wsadmin_stage_dir }}/{{ item }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    # ==========================================================================
    # 4) Smoke test - verify deploy can su to wsadmin
    # ==========================================================================
    - name: Smoke test - verify deploy can su to wsadmin
      block:
        - name: Run su to wsadmin with id/whoami
          ansible.builtin.shell: >
            set -euo pipefail &&
            {{ was_su_wsadmin_prefix | quote }} "id && whoami"
          args:
            executable: /bin/bash
          register: su_wsadmin_test
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Mark su-to-wsadmin OK
          ansible.builtin.set_fact:
            was_can_su_to_wsadmin: true
          run_once: true
          become: false

        - name: Show su-to-wsadmin success
          ansible.builtin.debug:
            msg: "SUCCESS: deploy can su to {{ was_run_user }} on DMGR host {{ was_dmgr_host }}"
          run_once: true
          become: false

      rescue:
        - name: Mark su-to-wsadmin FAILED
          ansible.builtin.set_fact:
            was_can_su_to_wsadmin: false
          run_once: true
          become: false

        - name: Collect diagnostic - deploy identity
          ansible.builtin.shell: >
            set -euo pipefail && id && whoami && groups
          args:
            executable: /bin/bash
          register: dmgr_deploy_id
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Collect diagnostic - su policy hints (best effort)
          ansible.builtin.shell: >
            set -euo pipefail &&
            (test -r /etc/pam.d/su && sed -n '1,200p' /etc/pam.d/su) || echo "cannot read /etc/pam.d/su" &&
            echo "----" &&
            (test -r /etc/login.defs && grep -E '^(SU_|SULOG|ENV_SUPATH|ENV_PATH)' /etc/login.defs || true)
          args:
            executable: /bin/bash
          register: dmgr_su_policy
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Collect diagnostic - tail /var/log/secure (best effort)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="/var/log/secure" &&
            if [ -r "$f" ]; then tail -n 120 "$f"; else echo "No readable $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_secure_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Show su-to-wsadmin failure diagnostics
          ansible.builtin.debug:
            msg: |
              FAILURE: deploy cannot su to {{ was_run_user }} non-interactively on DMGR host {{ was_dmgr_host }}.
              This often manifests in AAP as: "Shared connection ... closed".

              Fix options:
                - Allow deploy -> su - wsadmin without interactive restrictions on DMGR hosts, OR
                - Use SSH as wsadmin for DMGR hosts (separate credential), OR
                - Review PAM/su configuration on the DMGR host.

              --- deploy identity ---
              {{ dmgr_deploy_id.stdout | default('') }}

              --- su policy hints ---
              {{ dmgr_su_policy.stdout | default('') }}

              --- /var/log/secure tail ---
              {{ dmgr_secure_tail.stdout | default('') }}
          run_once: true
          become: false

        - name: Fail fast if su-to-wsadmin failure is fatal
          when: not was_skip_on_su_wsadmin_failure | bool
          ansible.builtin.fail:
            msg: "Cannot proceed: deploy cannot su to {{ was_run_user }} on DMGR host"
          run_once: true
      run_once: true

    - name: Set skip flag for downstream steps (su-to-wsadmin failure)
      ansible.builtin.set_fact:
        was_skip_due_to_su_wsadmin: "{{ was_skip_on_su_wsadmin_failure | bool and (not (was_can_su_to_wsadmin | default(false) | bool)) }}"
      run_once: true
      become: false

    # ==========================================================================
    # 5) SOAP reachability check (only if su-to-wsadmin works)
    # ==========================================================================
    - name: DMGR precheck - SOAP port reachable from DMGR host
      when: not was_skip_due_to_su_wsadmin
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec }}"
        state: started
      register: dmgr_soap_wait
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false
      failed_when: false
      changed_when: false

    - name: Set DMGR health flag
      when: not was_skip_due_to_su_wsadmin
      ansible.builtin.set_fact:
        was_dmgr_soap_reachable: "{{ (dmgr_soap_wait is not failed) and (dmgr_soap_wait.state is defined) and (dmgr_soap_wait.state == 'started') }}"
      run_once: true
      become: false

    - name: DMGR diag - collect diagnostics when SOAP not reachable
      when: not was_skip_due_to_su_wsadmin and (not (was_dmgr_soap_reachable | default(false)))
      block:
        - name: Collect diagnostic - netstat/ss for SOAP port
          ansible.builtin.shell: >
            set -euo pipefail &&
            (command -v ss >/dev/null 2>&1 && ss -ltnp | grep -E '(:{{ was_dmgr_soap_port }}\s)') ||
            (command -v netstat >/dev/null 2>&1 && netstat -ltnp 2>/dev/null | grep -E '(:{{ was_dmgr_soap_port }}\s)') ||
            echo "No ss/netstat output for port {{ was_dmgr_soap_port }} (or tools missing)."
          args:
            executable: /bin/bash
          register: dmgr_port_diag
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Collect diagnostic - tail wsadmin.traceout (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 120 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: dmgr_wsadmin_trace_tail
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Show SOAP unreachable diagnostics
          ansible.builtin.debug:
            msg: |
              FAILURE: DMGR SOAP port {{ was_dmgr_soap_port }} NOT reachable on {{ was_dmgr_host }} (localhost).
              --- Port listeners ---
              {{ dmgr_port_diag.stdout | default('') }}
              --- wsadmin.traceout tail ---
              {{ dmgr_wsadmin_trace_tail.stdout | default('') }}
          run_once: true
          become: false

        - name: Fail fast if DMGR SOAP unreachable is fatal
          when: was_fail_fast_on_dmgr_unreachable | bool
          ansible.builtin.fail:
            msg: "Cannot proceed: DMGR SOAP port {{ was_dmgr_soap_port }} not reachable"
          run_once: true
      run_once: true

    - name: Set skip flag for downstream steps (DMGR health)
      ansible.builtin.set_fact:
        was_skip_discovery_and_probes: >-
          {{
            was_skip_due_to_su_wsadmin
            or
            (not (was_dmgr_soap_reachable | default(false) | bool))
          }}
      run_once: true
      become: false

    - name: Show SOAP reachability success
      when: not was_skip_discovery_and_probes
      ansible.builtin.debug:
        msg: "SUCCESS: DMGR SOAP port {{ was_dmgr_soap_port }} is reachable on {{ was_dmgr_host }}"
      run_once: true
      become: false

    # ==========================================================================
    # 6) Discovery (skipped if DMGR unhealthy or su-to-wsadmin fails)
    # ==========================================================================
    - name: Build node list from limited hosts
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (run as wsadmin)
      when: not was_skip_discovery_and_probes
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/discover_targets.py'
        --nodes {{ was_nodes_in_scope | join(' ') }}"
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    - name: Discovery diag - show stdout/stderr if wsadmin failed
      when: not was_skip_discovery_and_probes and discovery_out.rc != 0
      block:
        - name: Show discovery failure output
          ansible.builtin.debug:
            msg: |
              FAILURE: Discovery failed rc={{ discovery_out.rc }}
              --- stdout ---
              {{ discovery_out.stdout | default('') }}
              --- stderr ---
              {{ discovery_out.stderr | default('') }}
          run_once: true

        - name: Tail wsadmin.traceout after discovery failure (if present)
          ansible.builtin.shell: >
            set -euo pipefail &&
            f="{{ was_dmgr_profile }}/logs/wsadmin.traceout" &&
            if [ -f "$f" ]; then tail -n 180 "$f"; else echo "No wsadmin.traceout at $f"; fi
          args:
            executable: /bin/bash
          register: wsadmin_trace_after_discovery
          delegate_to: "{{ was_dmgr_host }}"
          run_once: true
          changed_when: false
          become: false

        - name: Fail - discovery failed
          ansible.builtin.fail:
            msg: |
              Discover application servers via DMGR failed.
              --- wsadmin.traceout tail ---
              {{ wsadmin_trace_after_discovery.stdout | default('') }}
      run_once: true

    # ==========================================================================
    # 7) Parse discovery JSON output
    # ==========================================================================
    - name: Extract JSON payload from wsadmin output (last line)
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovery_json_raw: "{{ discovery_out.stdout_lines | default([]) | last | default('{}') }}"
      run_once: true
      become: false

    - name: Discovery diag - when JSON payload missing
      when: not was_skip_discovery_and_probes and (was_discovery_json_raw | length <= 2 or was_discovery_json_raw is not match('^\\s*\\{.*\\}\\s*$'))
      block:
        - name: Show discovery output head/tail
          ansible.builtin.debug:
            msg: |
              wsadmin output did not contain a valid JSON object on the last line.
              Last line: {{ was_discovery_json_raw }}
              --- first 800 chars ---
              {{ (discovery_out.stdout | default(''))[:800] }}
              --- last 800 chars ---
              {{ (discovery_out.stdout | default(''))[-800:] }}
          run_once: true

        - name: Fail - JSON payload missing
          ansible.builtin.fail:
            msg: "wsadmin output missing JSON payload"
      run_once: true

    - name: Parse discovery JSON payload
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovery_json: "{{ was_discovery_json_raw | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovered_targets_all: "{{ was_discovery_json.targets | default([]) }}"
      run_once: true
      become: false

    - name: Filter discovered targets to nodes in scope
      when: not was_skip_discovery_and_probes
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true
      become: false

    - name: Assert at least one target discovered
      when: not was_skip_discovery_and_probes
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes {{ was_nodes_in_scope }}.
          Check was_node_name host_vars and DMGR visibility.
      run_once: true
      become: false

    - name: Show discovered targets
      when: not was_skip_discovery_and_probes
      ansible.builtin.debug:
        msg: "SUCCESS: Discovered {{ was_discovered_targets | length }} application server(s): {{ was_discovered_targets | map(attribute='server') | list }}"
      run_once: true
      become: false

    # ==========================================================================
    # 8) Query runtime state for each discovered server
    # ==========================================================================
    - name: Query runtime state for each discovered server (run as wsadmin)
      when: not was_skip_discovery_and_probes
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' &&
        ./wsadmin.sh -quiet -lang jython
        -conntype SOAP -host 127.0.0.1 -port '{{ was_dmgr_soap_port }}'
        -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}'
        -f '{{ was_wsadmin_stage_dir }}/server_state.py'
        --node '{{ item.node }}'
        --server '{{ item.server }}'"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: false
      become: false

    - name: Summarize server states
      when: not was_skip_discovery_and_probes
      ansible.builtin.debug:
        msg: "{{ state_out.results | map(attribute='stdout') | list }}"
      run_once: true
      become: false

    # ==========================================================================
    # 9) Final summary
    # ==========================================================================
    - name: Validation summary
      ansible.builtin.debug:
        msg: |
          ============================================================
          VALIDATION SUMMARY for {{ was_dmgr_host }}
          ============================================================
          su-to-wsadmin:     {{ 'PASS' if (was_can_su_to_wsadmin | default(false)) else 'FAIL/SKIPPED' }}
          DMGR SOAP:         {{ 'PASS' if (was_dmgr_soap_reachable | default(false)) else 'FAIL/SKIPPED' }}
          Discovery:         {{ 'PASS (' ~ (was_discovered_targets | default([]) | length) ~ ' servers)' if not was_skip_discovery_and_probes else 'SKIPPED' }}
          ============================================================
      run_once: true
      become: false
