---
- name: Smoke test WAS/BAW discovery + wsadmin control (non-disruptive by default)
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  vars:
    was_smoketest_allow_changes: false

  tasks:
    - name: Show which hosts are in scope (AAP limit)
      ansible.builtin.debug:
        msg:
          - "ansible_play_hosts={{ ansible_play_hosts }}"
          - "was_dmgr_host={{ was_dmgr_host | default('UNSET') }}"
          - "was_dmgr_profile={{ was_dmgr_profile | default('UNSET') }}"
      run_once: true

    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_profile_path is defined
          - was_node_profile_path | length > 0
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Ensure DMGR vars (was_dmgr_host, was_dmgr_profile,
          was_wsadmin_user, was_wsadmin_pass) and per-host node vars (was_node_profile_path,
          was_node_name) are set via inventory or survey.

    - name: Stage wsadmin scripts to DMGR (safe)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_dmgr_profile }}/bin/{{ item }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Start DMGR (optional; needed after reboot if DMGR host was restarted)
      when: was_start_dmgr | default(true) | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        "{{ was_dmgr_profile }}/bin/startManager.sh"
      args:
        executable: /bin/bash
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      register: dmgr_start
      changed_when: dmgr_start.rc == 0
      failed_when: dmgr_start.rc != 0 and ("ADMU" not in (dmgr_start.stdout | default('')))

    - name: Wait for DMGR SOAP port to be reachable (local check on DMGR host)
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port | default(8879) }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec | default(300) }}"
        state: started
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Ensure nodeagent is started on each limited host (optional)
      when: was_start_nodeagent | default(true) | bool
      ansible.builtin.shell: >
        set -euo pipefail &&
        "{{ was_node_profile_path }}/bin/startNode.sh"
      args:
        executable: /bin/bash
      register: nodeagent_start
      changed_when: nodeagent_start.rc == 0
      failed_when: nodeagent_start.rc != 0 and ("ADMU" not in (nodeagent_start.stdout | default('')))

    - name: Build node list from limited hosts
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true

    - name: Discover application servers via DMGR (safe)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./discover_targets.py"
        --nodes {{ was_nodes_in_scope | join(' ') }}
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: discovery_out.rc != 0

    - name: Extract JSON payload candidates from wsadmin output
      ansible.builtin.set_fact:
        was_discovery_json_candidates: "{{ (discovery_out.stdout | string) | regex_findall('(?s)\\{.*?\\}(?=\\s*$)') }}"
      run_once: true

    - name: Assert JSON payload was found in wsadmin output
      ansible.builtin.assert:
        that:
          - was_discovery_json_candidates | length > 0
        fail_msg: >
          wsadmin output did not contain a trailing JSON object.
          First 800 chars:
          {{ (discovery_out.stdout | string)[:800] }}
      run_once: true

    - name: Parse discovery JSON payload (last candidate)
      ansible.builtin.set_fact:
        was_discovery_json: "{{ (was_discovery_json_candidates | last | string) | from_json }}"
      run_once: true

    - name: Build discovered target list
      ansible.builtin.set_fact:
        was_discovered_targets_all: "{{ was_discovery_json.targets | default([]) }}"
      run_once: true

    - name: Filter discovered targets to nodes in scope
      ansible.builtin.set_fact:
        was_discovered_targets: >-
          {{
            was_discovered_targets_all
            | selectattr('server', 'defined')
            | selectattr('node', 'in', was_nodes_in_scope)
            | list
            | sort(attribute='node')
          }}
      run_once: true

    - name: Fail if discovery returns zero targets (helps catch bad limits/node names)
      ansible.builtin.assert:
        that:
          - was_discovered_targets | length > 0
        fail_msg: >
          Discovery returned zero application servers for nodes {{ was_nodes_in_scope }}.
          Check was_node_name host_vars and DMGR visibility.
      run_once: true

    - name: Show discovered targets (node/server)
      ansible.builtin.debug:
        var: was_discovered_targets
      run_once: true

    - name: Query runtime state for each discovered server (safe)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./server_state.py"
        --node "{{ item.node }}"
        --server "{{ item.server }}"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: state_out.rc != 0

    - name: Initialize state lists
      ansible.builtin.set_fact:
        was_running_targets: []
        was_down_targets: []
        was_unknown_targets: []
      run_once: true

    - name: Classify targets by current state
      ansible.builtin.set_fact:
        was_running_targets: "{{ was_running_targets + [ item.item ] }}"
      when: (item.stdout | default('')) is search('=(RUNNING|STARTED)\\b')
      loop: "{{ state_out.results }}"
      loop_control:
        label: "{{ item.item.node }}/{{ item.item.server }}"
      run_once: true

    - name: Classify down targets (STOPPED/NOT_FOUND)
      ansible.builtin.set_fact:
        was_down_targets: "{{ was_down_targets + [ item.item ] }}"
      when: (item.stdout | default('')) is search('=(STOPPED|NOT_FOUND)\\b')
      loop: "{{ state_out.results }}"
      loop_control:
        label: "{{ item.item.node }}/{{ item.item.server }}"
      run_once: true

    - name: Classify unknown targets (everything else)
      ansible.builtin.set_fact:
        was_unknown_targets: "{{ was_unknown_targets + [ item.item ] }}"
      when: >
        (item.stdout | default('')) is not search('=(RUNNING|STARTED)\\b') and
        (item.stdout | default('')) is not search('=(STOPPED|NOT_FOUND)\\b')
      loop: "{{ state_out.results }}"
      loop_control:
        label: "{{ item.item.node }}/{{ item.item.server }}"
      run_once: true

    - name: Show sample raw wsadmin outputs (helps debug unexpected formats)
      ansible.builtin.debug:
        msg:
          - "target={{ item.item.node }}/{{ item.item.server }}"
          - "stdout={{ item.stdout | default('') }}"
          - "stderr={{ item.stderr | default('') }}"
      loop: "{{ state_out.results | default([]) }}"
      when: was_debug_wsadmin_output | default(false) | bool
      run_once: true

    - name: Summarize current states
      ansible.builtin.debug:
        msg:
          - "RUNNING/STARTED targets: {{ was_running_targets | length }}"
          - "STOPPED/NOT_FOUND targets: {{ was_down_targets | length }}"
          - "UNKNOWN targets: {{ was_unknown_targets | length }}"
      run_once: true

    - name: Fail if any UNKNOWN targets (recommended; indicates DMGR visibility or runtime issues)
      when: was_fail_on_unknown | default(true) | bool
      ansible.builtin.assert:
        that:
          - was_unknown_targets | length == 0
        fail_msg: >
          One or more targets returned UNKNOWN state. Investigate wsadmin connectivity/state.
      run_once: true

    - name: Probe START on already-running targets (should not change anything)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./control_server.py"
        --action start
        --node "{{ item.node }}"
        --server "{{ item.server }}"
        --timeout "{{ was_poll_timeout_sec | default(600) }}"
        --delay "{{ was_poll_delay_sec | default(5) }}"
      args:
        executable: /bin/bash
      register: start_probe_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_running_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: start_probe_out.rc != 0

    - name: Probe STOP on already-down targets (should not change anything)
      ansible.builtin.shell: >
        set -euo pipefail &&
        cd "{{ was_dmgr_profile }}/bin" &&
        ./wsadmin.sh -quiet
        -lang jython
        -user "{{ was_wsadmin_user }}"
        -password "{{ was_wsadmin_pass }}"
        -f "./control_server.py"
        --action stop
        --node "{{ item.node }}"
        --server "{{ item.server }}"
        --timeout "{{ was_poll_timeout_sec | default(600) }}"
        --delay "{{ was_poll_delay_sec | default(5) }}"
      args:
        executable: /bin/bash
      register: stop_probe_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_down_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: stop_probe_out.rc != 0

    - name: Fail if any probe indicates a real change (safety latch)
      when: not (was_smoketest_allow_changes | default(false) | bool)
      ansible.builtin.assert:
        that:
          - (start_probe_out.results | default([]) | selectattr('stdout', 'search', 'CHANGED:true') | list | length) == 0
          - (stop_probe_out.results  | default([]) | selectattr('stdout', 'search', 'CHANGED:true') | list | length) == 0
        fail_msg: >
          Smoke test detected CHANGED:true during control probes.
          This indicates the probes would have started/stopped something.
          If you intended to allow changes, set was_smoketest_allow_changes=true.
      run_once: true

    - name: Smoke test summary (probes)
      ansible.builtin.debug:
        msg:
          - "Start probes executed: {{ (start_probe_out.results | default([])) | length }}"
          - "Stop probes executed:  {{ (stop_probe_out.results  | default([])) | length }}"
          - "No-change policy enforced: {{ not (was_smoketest_allow_changes | default(false) | bool) }}"
      run_once: true
