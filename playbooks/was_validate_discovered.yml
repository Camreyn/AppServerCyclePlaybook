---
- name: Validate discovered WAS/BAW servers (wsadmin discovery + state + idempotent probes)
  hosts: was_all_nodes
  gather_facts: false
  serial: 1

  become: true
  become_user: root
  become_method: su

  vars:
    was_run_user: "{{ was_run_user | default('wsadmin') }}"
    was_su_wsadmin_prefix: "/bin/su - {{ was_run_user }} -c"
    was_smoketest_allow_changes: false

  tasks:
    - name: Validate required vars (DMGR + node)
      ansible.builtin.assert:
        that:
          - was_dmgr_host is defined
          - was_dmgr_profile is defined
          - was_wsadmin_user is defined
          - was_wsadmin_pass is defined
          - was_node_name is defined
          - was_node_name | length > 0
        fail_msg: >
          Missing required variables. Ensure DMGR vars and was_node_name are set.
      run_once: true
      become: false

    - name: Copy wsadmin scripts to DMGR profile bin (as root)
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../roles/was_wsadmin/files/{{ item }}"
        dest: "{{ was_dmgr_profile }}/bin/{{ item }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Ensure wsadmin owns staged scripts on DMGR
      ansible.builtin.file:
        path: "{{ was_dmgr_profile }}/bin/{{ item }}"
        owner: "{{ was_run_user }}"
        group: "{{ was_run_user }}"
        mode: "0755"
      loop:
        - discover_targets.py
        - server_state.py
        - control_server.py
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true

    - name: Wait for DMGR SOAP port to be reachable (local check on DMGR host)
      ansible.builtin.wait_for:
        host: "127.0.0.1"
        port: "{{ was_dmgr_soap_port | default(8879) }}"
        timeout: "{{ was_dmgr_soap_wait_timeout_sec | default(300) }}"
        state: started
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      become: false

    - name: Build node list from limited hosts
      ansible.builtin.set_fact:
        was_nodes_in_scope: >-
          {{
            ansible_play_hosts
            | map('extract', hostvars, 'was_node_name')
            | list
            | unique
          }}
      run_once: true
      become: false

    - name: Discover application servers via DMGR (run as wsadmin)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' && ./wsadmin.sh -quiet -lang jython -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}' -f './discover_targets.py' --nodes {{ was_nodes_in_scope | join(' ') }}"
      args:
        executable: /bin/bash
      register: discovery_out
      delegate_to: "{{ was_dmgr_host }}"
      run_once: true
      changed_when: false
      failed_when: discovery_out.rc != 0

    - name: Extract JSON payload candidates from wsadmin output
      ansible.builtin.set_fact:
        was_discovery_json_candidates: "{{ (discovery_out.stdout | string) | regex_findall('(?s)\\{.*?\\}(?=\\s*$)') }}"
      run_once: true
      become: false

    - name: Parse discovery JSON payload (last candidate)
      ansible.builtin.set_fact:
        was_discovery_json: "{{ (was_discovery_json_candidates | last | string) | from_json }}"
      run_once: true
      become: false

    - name: Build discovered target list
      ansible.builtin.set_fact:
        was_discovered_targets: "{{ (was_discovery_json.targets | default([])) | list }}"
      run_once: true
      become: false

    - name: Query runtime state for each discovered server (run as wsadmin)
      ansible.builtin.shell: >
        set -euo pipefail &&
        {{ was_su_wsadmin_prefix | quote }} "cd '{{ was_dmgr_profile }}/bin' && ./wsadmin.sh -quiet -lang jython -user '{{ was_wsadmin_user }}' -password '{{ was_wsadmin_pass }}' -f './server_state.py' --node '{{ item.node }}' --server '{{ item.server }}'"
      args:
        executable: /bin/bash
      register: state_out
      delegate_to: "{{ was_dmgr_host }}"
      loop: "{{ was_discovered_targets }}"
      loop_control:
        label: "{{ item.node }}/{{ item.server }}"
      run_once: true
      changed_when: false
      failed_when: state_out.rc != 0
